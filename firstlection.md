# ПЕРВАЯ ЛЕКЦИЯ

<a name="up"></a>

**СОДЕРЖАНИЕ**
1. [Введение в JavaScript](#1)
2. [Подключение скриптов JavaScript](#2)
3. [Алгоритмы и типы данных](#3)
4. [Приведение типов](#4)
5. [Переменные](#5)
6. [Значение переменных](#6)
7. [Практическое применение](#7)
8. [Функции](#8)
9. [Нелинейные алгоритмы](#9)

***
## Введение в JavaScript

<a name="1"></a>

>**JavaScript** - это язык *программирования сценариев* (script) со слабой типизацией и динамическим приведением типов.

Язык сценариев - язык системной интеграции, который работает с готовыми программными компонентами:
* **DOM** - *Document Object Model*, API для работы со страницей: разметка, события
* **BOM** - *Browser Object Model*, API для работы с браузером: история, хранилища, cookies, таймеры, таймауты
* **HTTP** - работа с сетью
* Графика `<canvas />` - прослойка для создания графики

Приведение типов - если операнды переданные оператору разного типа, они автоматически приводятся к типу, в котором операцию можно выполнить. Тип в который будут приведены операнды зависит от оператора.  
К примеру при приведении типов у строкового оператора сложения всегда будет приоритет над математическим, поэтому если один из операндов операции сложения будет строкой, сложение будет строковым.  
Пример:
* `'10' / '2' === 5` - поскольку используется математический оператор, а операнды являются строками, содержащими числа, то строковые операнды станут числами и приведение произведется к числу

Динамическое приведение типов — это когда язык программирования сам переводит значения, переданные оператору в тот тип, в котором операция может быть выполнена. Из строки невозможно вычесть число, поэтому для проведения операции вычитания, JS приведет строку '10' к числу.
  
Javascript работает со следующими движками:
* MS Internet Explorer 11 (на интенсиве не поддерживался)
* MS Edge
* Gecko (Moz;//a)
* Webkit (Safari)
* Blink (*fork Webkit'a*) (Chrome, Chromium, Opera, Yandex...)

[К содержанию](#up)
***
## Подключение скриптов JavaScript

<a name="2"></a>

Для использования скриптов языка javascript в теле **html** документа, используется парный тег `<script>`. Если скрипт указывается в начале **html** документа, в теге `<head>`, то он выполняется до загрузки содержимого страницы, поэтому принято подключать скрипты в конце **html** документа, перед закрывающим тегом `</body>`.  
Использование скрипта в `<head>` оправдано только, если такой скрипт необходимо выполнять до загрузки содержимого страницы, к примеру, библиотеки, счетчики и прочие внешние ресурсы.

Код может писаться в самом **html**-документе, для этого его нужно разместить между тегами `<script></script>`. Если код уникален и используется на нескольких страницах, выгоднее подключить внешний файл *.js используя атрибут **src**.  
>**Важно:** если вы подключаете внешний js-файл, то код внутри тегов `<script></script>` не выполнится.

Примеры использования ниже:

    /* Неуникальный код, используемый только на этой странице */
    <script>
       alert('Привет, мир!');
    </script>

    /* Подключение внешного javascript-файла, который может использоваться на различных страницах */
    <script src="js/script.js"></script>

    /* Если подключен внешний js-файл, код внутри тега не воспроизведется */
    <script src="js/script.js"> alert('Сообщение, которое не будет показано'); </script>

    /* Чтобы выполнить помимо подключенного внешнего скрипта, скрипт записанный внутри тега,
       нужно подключить второй тег
    */
    <script src="js/script.js"></script>
    <script> alert('Сообщение, будет показано'); </script>

>Конструкция **alert();** выводит посреди страницы сообщение, которое вы прописали в круглых скобках.

Если необходимо чтобы скрипт выполнялся вместе с загрузкой страницы, можно использоваться специальные атрибуты для тега `<script>`, которые позволят странице загружаться одновременно с работой скрипта.  
Есть два таких атрибута:
* **async** - cкрипт с таким атрибутом начинает загружаться сразу как встретится в разметке, а выполнится как только загрузка закончится
* **defer** - работает почти как async, разница в том что код выполнится после полной загрузки страницы.

Однако у них есть свои недостатки о которых будет написано позже.

[К содержанию](#up)
***
## Алгоритмы и типы данных

<a name="3"></a>

>**Алгоритм** - законченный и упорядоченный набор действий, которые нужно предпринять, чтобы достигнуть прогнозируемого результа.
* **Закончено** - заранее известно окончательное количество шагов, необходимое для получения решения
* **Упорядочено** - каждый шаг выполняется на определенном этапе
* **Прогнозируемо** - результат выполнения алгоритма предсказуем, мы всегда можем предположить что получится в конце.

Давайте попробуем составить алгоритм, на основе математической задачи из школьного курса (задача рассматривалась на интенсиве)

    // Два велосипедиста одновременно выехали навстречу
    // друг-другу из двух поселков и встретились через
    // 3 часа. Первый велосипедист ехал со скоростью
    // 12 км/ч, а второй — 14 км/ч. На каком расстоянии
    // находятся поселки?

    // Дано:
    // t = 3 ч
    // V1 = 12 км/ч
    // V2 = 14 км/ч
    // S = ? км

В примере выше, мы взяли задачу и вытащили из нее исходные данные, с которыми мы должны оперировать чтобы решить задачу.  
>**Обратите внимание:** Двумя слешами отделяются строчки комментариев (`//`), в языке **JavaScript**

**ТИПЫ ДАННЫХ**

Какие типы данных могут присутствовать в алгоритме?
* **Примитивные**
  * **Числа** (*number*) - формат данных, для представления числовой информации: целых, дробных чисел, а также иных описанных ниже.
    * Записываются без дополнительных символов. Пример: (`3, 12, 128`)
    * Поддерживается работа с целыми и дробными числами, дробная часть отделяется точкой. Пример: (`0.5, 0.128, 1.2`)
    * Существует дополнительное значение: `Infinity` - бесконечность, положительная или отрицательная соответственно
    * И еще одно: `NaN` - неизвестный числовой результат
    * Целые числа могут быть записаны в десятичном (принятом у человеков) и шестнадцатеричном формате (`0xFF`)
  * **Строки** (*string*) - формат данных, для представления текстовой информации
    * Записывается с использованием дополнительных символов (кавычек), поддерживаются одинарные и двойные кавычки:  
    `'Hello, I am a string';`  
    `"Hello, I am also a string";`
    * Называется строками, поскольку переносы, пробелы и отступы являются обычными символами, и поэтому весь текст хранится в виде одной длинной последовательности символов
    * В случае, если в строке нужно использовать специальный символ, используется экранирование (использование специальных символов)
      * `\t` - табуляция перед текстом. Пример: (`'\tHello, I am a string'`)
      * `\'` - вставка символа одинарной кавычки. Пример: (`'Hello, I\'am a string'`)
      * `\n` - переход на новую строку. Пример: (`'Hello,\nI am a string'`)
  * **Логические** (*булевы значения*) -  (`true`, `false`) - *расписать подробнее*
  * **Служебные** - (`null`, `undefined`) - *расписать подробнее*
* **Сложные**
  * **Объекты** - *указать какие*

Для проверки типа значения данных можно воспользоваться оператором `typeof`.
>Конструкция **console.log();** выведет в консоль содержимое круглых скобок, в виде "log: значение"

    console.log(typeof 1)
    // log: "number"

    console.log(typeof 1 + 2)
    // log: "number2"

    console.log(typeof 'text');
    // log: "string"

    console.log(typeof true);
    // log: "boolean"

    console.log(typeof undefined);
    // log: "undefined"

    console.log(typeof null);
    // log: "object"

    console.log(typeof console.log);
    // log: "function"

    console.log(typeof typeof);
    // log: SyntaxError: expected expression, got ')'

Важно помнить про оператор «скобки», который изменяет приоритет выполнения операторов (например, 2+2*2 против (2+2)*2 )

**ТИПЫ ОПЕРАТОРОВ**

Как производить различные действия с данными? Для этого используются различные операторы.  
Оператор - минимальная единица языка, команда. Оператор принимает несколько значений, преобразует их и возвращает новое значение.
* **Унарные** - операторы которые работают с одним значением
    * Унарный плюс `+` и унарный минус `-` . Пример: (`+Infinity`, `-Infinity`)
* **Бинарные** - операторы работающие с двумя значениями, в них входят:
    * Математические
    * Строковые
    * Логические
    * Служебные
* **Тернарный** - оператор (единственный в языке), принимает на вход три значения, выдавая результат в зависимости  от того, является ли первое значение правдой или ложью. Примеры:
    * `если : то ? иначе`
    * `true ? 'Больше' : 'Меньше'` (результат "Больше")
    * `false ? 'Больше' : 'Меньше'` (результат "Меньше")

**ВИДЫ ОПЕРАТОРОВ**

* **Математический** - производит вычисления с числами, при этом приоритет операторов такой же как и в математике.
    * `+` - сложение двух операндов. Пример:  
    `2 + 3 === 5`
    * `-` - вычитание из левого операнда, правого операнда. Пример:  
    `3 - 1 === 2`
    * `*` - умножение одного операнда на другой. Пример:  
    `2 * 3 === 6`
    * `/` - деление левого операнда, на правый операнд. Пример:  
    `21 / 2 === 10.5`
    * `%` - получение остатка от деления левого операнда на правый. Примеры:  
    `21 % 5 === 5`  
    `3 % 5 === 3`

>**Важно** - все остальные математические операции производятся с помощью объекта `Math`

    console.log(Math.sqrt(16)); // Возвращает квадратный корень числа
    // log: 4
    console.log(Math.abs(-2)); // Возвращает абсолютное значение числа
    // log: 2
    console.log(Math.pow(3, 2)); // Возвращает возведение в степень (3 в степени 2)
    // log: 9

    console.log(Math.PI); // Число пи
    // log: 3.141592653589793
    console.log(Math.LOG10E); // Представляет десятичный логарифм из e
    // log: 0.4342944819032518

* **Строковый** - как и тернарный, единственный в языке, позволяет соединять несколько строк в одну
    * `'текст' + 'текст' === 'тексттекст'` - поскольку в строке, все элементы являются символами, и пробелы тоже, то строки будут соеденены без пробела
    * ``"текст, " + '1 текст' === 'текст, 1 текст'`` - вне зависимости от типа кавычек обрамляющих текст, мы получим необходимый результат
    * `'10' + 2 = '102'` - даже если первое значения являясь строкой будет слагаться со вторым операндом-числом, то будет выполнена операция сложения строк
* **Логические**
  * Операторы сравнения
    * `>` - операнд слева больше операнда справа
    * `<` - операнд слева меньше операнда справа
    * `>=` - больше или равно
    * `<=` - меньше или равно
    * `!=` - операнд слева не равен операнду справа
    * `==` - операнд слева равен по значению операнду справа. Пример:
    `'2' == 2` (`true`), `2 == 2` (`true`)
    * `===` - операнд слева равен по значению и типу, операнду справа. Пример:
    `'2' === 2` (`false`), `2 === 2` (`true`).
  * Операторы булевой логики
    * Оператор `&&` или «логическое И» возвращает `true` только в том случае, если оба условия, слева и справа от него, возвращают `true`.
    * Оператор `||` или «логическое ИЛИ» возвращает `true` если любое из условий слева или справа от него, возвращают `true`.
* **Служебные** - *указать какие*

[К содержанию](#up)
***

## Приведение типов

<a name="4"></a>

**ЯВНОЕ ПРИВЕДЕНИЕ ТИПОВ**

В предыдущей главе упоминалось о том, что при при сложении строки с числом, число будет приведено к строковму типу данных. А если к примеру нам необходимо заранее привести то или иное значение к определенному типу? Для этого используются специальные встроенные методы

* Для приведения к числу:
  * Для превращения иного типа в *целое* число, используется специальная команда `parseInt();`, для которой нужно задать два параметра. Первый, это то значение которое нужно перевести в число, а второй - числовая система в которую нужно перевести число (двоичная, восьмеричная, десятичная, шестнадцатеричная). Пример:  
  `parseInt(100, 2) === 4;`  
  `parseInt('100', 8) === 64;`  
  `parseInt('100вася', 10) === 100;`  
  `parseInt('100.2 привет, как дела?', 10) === 100;`  
  `parseInt(0xFF, 10) === 255;`  
  `parseInt('100', 16) === 256;`
  * Для первращения строки в *дробное* число, используется специальная команда `parseFloat();`. В которую достаточно передать необходимое значение. Пример:  
  `parseFloat('10.2') === 10.2;`  
  `parseFloat('10.0') === 10;`  
  Еще один важный момент по поводу чисел в JS — из-за особенностей формата float, могут возникать погрешности при округлении результата операций. Поэтому, всегда старайтесь проверять результаты операций
* Для приведения к строке использвуется *метод* `.toString()`. Для того чтобы привести некое значение к строке при помощи этого метода, укажите его перед перед точкой: `test.toString()`.

Важный момент, если вы не используете переменную, а пишете непосредственно число (ну мало ли), после числа нужно писать дополнительную точку (`10..toString()`). Если число дробное, ставить точку не нужно (`10.0.toString()`). Если после целого числа точку не поставить, консоль выдаст ошибку `Uncaught SyntaxError`.

**ПРИВЕДЕНИЕ ОПЕРАНДАМИ**

Если нам по какой-то причине нужно использовать приведение к типу укороченным способом, то можно воспользоваться следующими способами.

* Для приведения к числу, используем унарные операторы минус или плюс:
    * `+'10' === 10`
    * `-'3' === -3`
* Для приведения к строке можно прибавить число к пустой строке:
    * `3 + '' === '3'`
* Для приведения к булевому значению, можно воспользоваться двойным отрицанием:
    * `!!0 === false`
    * `!!1 === true`

[К содержанию](#up)
***
## Переменные

<a name="5"></a>

>**Переменная** - способ запомнить значения, чтобы использовать их после не вычисляя повторно, а просто обращаясь к значению по имени

Для того чтобы создать переменную (в языке JavaScript) нужно использовать специальное ключевое слово `var`. Название переменной пишется через пробел после ввода этой команды:
* `var peremennaya`

В названии переменной можно использовать буквы (латинские), цифры (но только не в начале), специальные символы (не являющиеся операторами, а также пробелами), также не стоит называет переменную так же, как существующие конструкции языка:
* Так можно
  * `var value1`
  * `var OnePlusTwo`
  * `var $Price`
  * `var _firstlection`
* Так нельзя
  * `var 1value`
  * `var one+two`
  * `var var=let сonst`
  * `vat function`

Для имени переменной очень важен регистр, в языке JavaScript, переменные, названные одинаково, но имеющие разный регистр букв, будут считаться разными переменными. Пример:
* Это одна переменная
    * `var one`
* Это другая переменная
    * `var onE`
* Это третья переменная
    * `var oNe`
* Это совершенно другая переменная
    * `var ONE`

При создании простых переменных, которые будут использоваться как счетчики (к примеру в циклах), можно называть переменную одним символом (для цикла, часто используемое сокращение "`i`" - index).
Для создания переменной, которая будет хранить какое-то важное значение, желательно использовать полное название того, что содержится в этой переменной, также, при написании полного имени, первую букву переменной принято писать строчной.  
Константы принято писать заглавными буквами, используя вместо пробелов нижнее подчеркивание: `MAX_NUMBER`.
Кстати, по правилам написания языка, в конце каждой законченной логической конструкции принято ставить точку с запятой "`;`" (также как и в русском языке, принято ставить точку в конце предложения):

    //Время которое проехали велосипедисты
    var time;
    
    //Скорость первого велосипедиста
    var speedOfFirstCyclist;

    //Скорость второго велосипедиста
    var speedOfSecondCyclist;

>**Важно** - название для переменной должно быть существительным, название для функции должно быть глаголом

Вообще, специально для написания различных имен переменных придумано два способа
* **сamelСase** (как горбы у верблюда) - слова не отделяюься пробелами, каждое последующее слово начинается с заглавной буквы: `speedOfFirstCyclist`, `speedOfSecondCyclist`, `LevelSequence` и так далее
* **snike_case** (как извивающаяся змейка) - вместо пробелов слова отделяются нижним подчеркиванием, каждое последующее слово начинается с прописной буквы: `speed_of_first_cyclist`, `speed_of_second_cyclist`, `level_sequence` и так далее. Похожий принцип применятся для записи констант.

[К содержанию](#up)
***
## Значение переменных

<a name="6"></a>

Свежесозданная переменная содержит в себе служебное значение `undefined`, которые буквально переводится как `не определено`. Иными словами, каждая созданная переменная, до того как ей будет присвоено какой-либо значение, не будет определена к какому-то иному значению.

Для того чтобы задать переменной то или иное значение, нужно использовать специальный *оператор присваивания*, которые выглядит как символ `=`. При помощи него можно задать переменной любое значение из перечисленных выше типов данных (кроме наверное `undefined` поскольку она и так его в себе уже содержит):

    /* конструкция "var" используется для того чтобы создать переменную,
       если переменная с таким значением уже существует, снова создавать ее не требуется
    */
    var new;
    new = 1;
    new = 0.5;
    new = +Infinity;
    new = NaN;
    new = 0xFF;
    new = 'text';
    new = "text";
    new = true;
    new = false;
    new = null;

Переменная может хранить только только одно значение, если назначить в переменную новое значение, то старое сотрется, а вместо него будет хранится новое. Также, если переменной присваивать какую-либо операцию, к примеру математическую, или текстовую, то в переменную запишется результат этой операции.  
Это акутально даже, если в операции присутствует сама переменная:
    
    //Создаем переменную "new" с хранящимся в ней значением 1
    var new = 1;

    //Выведем значение переменной в консоль
    console.log(new); // log: 1

    //Мы перезаписали существующую переменную, и в консоль выведется новое значение
    new = 2;
    console.log(new); // log: 2

    /* При помощи математического оператора "+" мы произвели сложение двух чисел,
       и присвоили его переменной, в консоль вывелся результат
    */
    new = 2 + 3;
    console.log(new); // log: 5

    /* При помощи математического оператора "-" мы вычли из предыдущей переменной "new",
       которая содержала в себе значение "5", число "1",
       и результат этой операции записали в эту же переменную,
       новое значение переменной выведется в консоль
    */
    new = new - 1;
    console.log(new); // log: 4

    //Повторим для закрепления
    console.log(new); // log: 4
    new = new - 1;
    console.log(new); // log: 3
    new = new - 1;
    console.log(new); // log: 2
    new = new * 2
    console.log(new); // log: 4

[К содержанию](#up)
***
## Практическое применение

<a name="7"></a>

Теперь, когда мы знаем какие бывают типы данных и какие бывают операторы для вычислений, а также зная как создавать переменные мы можем решить нашу задачу:

    // Два велосипедиста одновременно выехали навстречу
    // друг-другу из двух поселков и встретились через
    // 3 часа. Первый велосипедист ехал со скоростью
    // 12 км/ч, а второй — 14 км/ч. На каком расстоянии
    // находятся поселки?

    // Дано:
    // t = 3 ч
    // V1 = 12 км/ч
    // V2 = 14 км/ч
    // S = ? км

Первым делом желательно продумать каждый шаг, на которые нужно будет разбить нашу задачу:

    // Алгоритм
    // 1. Найти расстояние, которое проехал первый
    //    велосипедист, умножив скорость на время
    // 2. Найти расстояние, которое проехал второй
    //    велосипедист
    // 3. Сложить полученные расстояния

Затем, создаем переменные с базовыми данными которыми мы будем оперировать на каждом шаге:

    // Дано:
    // t = 3 ч
    // V1 = 12 км/ч
    // V2 = 14 км/ч
    // S = ? км

    var time = 3;
    var speedOfFirstCyclist = 12;
    var speedOfSecondCyclist = 14;
    // Переменную для расстояния между поселками создавать не будем, а зададим ее в процессе вычисления

Опишем все необходимые вычисления которые сделаем с текущими переменными:

    // 1. Найти расстояние, которое проехал первый
    //    велосипедист, умножив скорость на время
    var distanceOfFirstCyclist = speedOfFirstCyclist * time;

    // 2. Найти расстояние, которое проехал второй
    //    велосипедист
    var distanceOfSecondCyclist = speedOfSecondCyclist * time;

    // 3. Сложить полученные расстояния
    var totalDistance = distanceOfFirstCyclist + distanceOfSecondCyclist;

И выведем результат в консоль:

    console.log('Поселки находятся на расстоянии ' + totalDistance + 'км.');
    // log: "Поселки находятся на расстоянии 78км."

[К содержанию](#up)
***
## Функции

<a name="8"></a>

Отлично, мы научились решать простые задачи. Но что, если у нас несколько подобных, однотипных задач, с разными входными данными, а вместо велосипедисов, скажем, автомобилисты? Каждый раз описывать один и тот же порядок действий, меняя только названия переменных и числа - не выгодно. Цель программ - упрощать вычисления.

Среди программистов есть даже специальный принцип звучащий как `DRY`. Он расшифровывается следующим образом:  
>`DRY` (Don’t repeat yourself / Не повторяйся) - *Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы*

Иными словами, если ты написал какой-то код, который работает, не пиши новый, похожий, или во многом повторяющий его снова чтобы решить похожую задачу, а используй его повторно. Как-то так.
И в данном случае нам в этом помогут *функции*.

>**Функция** - это способ использовать код повторно.

Функция создается похожим на переменную способом. При создании функции также используется команда `var`, функция также как и переменная, имеет имя.

Отличие заключается в том, что функция имеет специальное **поле** куда можно записать *параметры* функции, которые будут в ней использоваться.  
Функция имеет *тело кода* куда записывается код, который будет выполняться при *вызове* функции.  
А также, в теле кода функции можно использовать специальную служебную команду `return`, которая останавливает выполнение кода функции и указывает на ту переменную, значение которой должно *возвращаться* функцией.

Как это выглядит.

    // Задаем имя функции, входные параметры (в данном случае "text"),
    // Код, который должен выполнятся при ее вызове:
    // Используя знания о превращении числа в строку, превращаем входной параметр в строку
    // А затем указваем командой "return" на переменную значение которой нам нужно получить

    var nameFuncton = function(text) {
        var text = text.toString();
        return text;
    };
    
    //Теперь вызовем эту функцию, чтобы результат вывелся в консоль

    console.log( nameFuncton() );
    // log: "undefined"

Обратите внимание, в качестве результата нам вывелась строка `"undefined"`, поскольку именно такое значение имеет переменная без явного присвоенного ей значения. И это значение стало строкой.  
Если мы хотим задать какое-то конкретное значение, нужно указать внутри скобок нужное нам значение:

    console.log( nameFuncton(1234) );
    // log: "1234"

Заметьте, что при вызове функции в консоль мы после имени функции указали круглые скобки. Если бы мы этого не сделали, JS решил бы что это переменная и в консоль вывелась бы содержимое этой переменной, а не результат вычислений:

    //Круглые скобки после имени функции указывают на то, что функция должна выполнится
    //иначе, мы получим содержимое тела функции

    console.log( nameFuncton );

    // log: function (text) {
    //  var text = text.toString();
    //  return text;
    //  }

Круглые скобки после имени функции, это призыв к действию для JS выполнить эту функцию, запустить код, который мы в нее внесли.

Теперь, умея использовать функции, давайте оптимизируем нашу задачу:

    // создадим функцию calculateDistance и перенесем в нее наши вычисления
    // в качестве параметров, укажем переменные которые ранее создавали для входных данных
    // укажем что нужно возвращать значение последнего вычисления.

    var calculateDistance = function(time, speedOfFirstCyclist, speedOfSecondCyclist) {
        var distanceOfFirstCyclist = speedOfFirstCyclist * time;
        var distanceOfSecondCyclist = speedOfSecondCyclist * time;
        var totalDistance = distanceOfFirstCyclist + distanceOfSecondCyclist;
        return totalDistance
    };

    // Наведем красоту, введя повторяющийся текст в переменные, следуя принципу DRY
    var text = 'Поселки находятся на расстоянии ';
    var measureUnit = 'км.'

    // Вызовем функцию указав время, и скорость для двух велосипедистов (или автомобилистов)
    console.log(text + calculateDistance(3, 12, 14) + measureUnit);
    сonsole.log(text + calculateDistance(5, 25, 8) + measureUnit);

    // log: "Поселки находятся на расстоянии 78км."
    // log: "Поселки находятся на расстоянии 165км."

Отлично! Мы решили задачу, а также теперь, меняя входные данные мы можем решать много задач, с разными входными данными.

[К содержанию](#up)
***
## Нелинейные алгоритмы

<a name="9"></a>

Когда входные данные заранее определены, все отлично. Но могут быть ситуации, когда нам известно какие могут быть входящие значения, известно как на них реагировать, но также известно что в зависимости от того, какие мы получим данные, мы должны с этими данными сделать разные действия

    //Сходи в магазин, если там есть яйца, купи десяток
    //Если нету, купи буханку хлеба

Это как раз такой вариант нелинейного алгоритма. Мы знаем как поступать если мы зайдем в магазин и обнаружим на полке наличие яиц, и знаем что нам делать если их не будет. Но мы, пока не сходим в магазин, не узнаем, есть ли там яйца или нет. А алгоритм нужно продумать, исходя из обоих ситуаций.
И тут нам на помощь приходят *условные операторы*.

>**Условный оператор** - конструкция языка, выполняющая определенный набор действий только при выполнении некого логического выражения

В JavaScript условным оператором является следующая конструкция:

    if (условие){
        первое тело кода
    } else {
        второе тело кода
    }

Давайте рассмотрим ее поподробнее

    //"if" переводится как "если", в круглых скобках мы указываем причину выполнения кода
    // содержащегося в первом условии, и в фигурных скобках сам код
    if (true) {
        console.log('Если if === true вы увидете это сообщение');
    }
    // Если же по какой-то причине, входные данные не удволетворяют условию "if"
    // то есть "if (false)", то выполняется второй участок кода
    else {
        console.log('Если if === false то выполнится вторая часть кода');
    };

Рассмотрим этот алгоритм на примере нашей задачи:

    // Создаем функцию, где входным параметром будет наличие (true) или отсутствие (false) в магазине яиц
    var buySomeBread = finction(eggs) {
        // Установим этот же параметр в качестве выполнения первого, основного участка кода
        if (eggs){
            // Если eggs === true, покупаем (возвращаем из функции) 10 яиц
            return 10;
        } else {
            // Если eggs === false, покупаем (возвращаем из функции) 1 буханку хлеба
            return 1;
        }
    };
    //Проверяем работу функции с вложенным условием:
    
    console.log(buySomeBred(true));
    // log: 10

    console.log(buySomeBred(false));
    // log: 1

На первый взгляд все хорошо, но лишь на первый.  
Во первых, как мы помним, функция заканчивает выполнение кода как только доходит до команды `return`. И, если оптимизировать код, то else можно не писать, поскольку если `if` не `true`, то можно указать второй `return` в теле самой функции:

    var buySomeBread = finction(eggs) {
        if (eggs){
            return 10;
        }
        return 1;
    };

Во вторых, обратите внимание, что в `if` не выполняется никаких сложных действий - не создаются переменные, не описываются никакие алгоритмы, просто возвращается одно значение, одно число. В `else` аналогично. Поэтому для выполнения такого простого кода, отлично подойдет *тернарный оператор*, который, также как и конструкция с условием, возвращает либо одно либо другое значение, в зависимости от того, является ли первое значение `true` или `false`:

    var buySomeBread = function(eggs) {
        return eggs ? 10 : 1;
    };
    //Снова проверим работу функции. Несмотря на то что мы сильно ее упростили, на функционал это никак не повлияло.

    console.log(buySomeBred(true));
    // log: 10
    console.log(buySomeBred(false));
    // log: 1

**ВАЖНОЕ УТОЧНЕНИЕ**

Работу с условиями мы практически разобрали. Осталось одно важное **но!**. Во время написания различных программ вы можете встретится с конструкциями следующего типа:

    if(...){
        ...
    }
    if(...){
        ...
    } else {
        ...
    };

А также

    if(...){
        ...
    }
    else if(...){
        ...
    } else {
        ...
    };

>**else if** - работает похожим на `if` образом, отличие в том, что код выполняется только в том случае, если один или несколько предыдущих `if` вернули `false` и не выполнились.

Рассмотрим наглядно на примере (это важно, поскольку в определенный момент у меня из-за этой фигни, не работала программа и я не мог понять в чем дело):

    var a = 1;
    if (a > 0){
        console.log('переменная \'а\' больше нуля');
    }
    if (a === 1){
        console.log('переменная \'а\' равна единице');
    } else {
        console.log('переменная \'а\' не больше нуля или не равна единице');
    };
    // Выполнив данный код, мы получим в консоль следующее:
    // log: "переменная 'а' больше нуля"
    // log: "переменная 'а' равна единице"

Но, если мы немного поменяем код, указав вместо второго `if` - `else if`, то у нас изменится вывод результата:

    var a = 1;
    if (a > 0){
        console.log('переменная \'а\' больше нуля');
    }
    else if (a === 1){
        console.log('переменная \'а\' равна единице');
    } else {
        console.log('переменная \'а\' не больше нуля или не равна единице');
    };
    // Выполнив данный код, мы получим в консоль следующее:
    // log: "переменная 'а' больше нуля"

Несмотря на то что `else if` удволетворяет условиям входных данных, выполнятся она не будет. Давайте еще немного изменим программу, поменяв знак сравнения: `>` - "больше", на другой: `<` - "меньше".

    var a = 1;
    if (a < 0){
        console.log('переменная \'а\' больше нуля');
    }
    else if (a === 1){
        console.log('переменная \'а\' равна единице');
    } else {
        console.log('переменная \'а\' не больше нуля или не равна единице');
    };
    // Выполнив данный код, мы получим в консоль следующее:
    // log: "переменная 'а' равна единице"

Теперь, когда первое условие не удволетворяет входным данным, выполнился код во второй части алоритма, который по прежнему удволетворен, ведь `a === 1`.
Для очистки совести приравняем переменную `a` тексту `'text'`.

    var a = 'text';
    if (a < 0){
        console.log('переменная \'а\' больше нуля');
    }
    else if (a === 1){
        console.log('переменная \'а\' равна единице');
    } else {
        console.log('переменная \'а\' не больше нуля или не равна единице');
    };
    // Выполнив данный код, мы получим в консоль следующее:
    // log: "переменная 'а' не больше нуля или не равна единице"

Поскольку входные данные не соответствуют первым двум условиям, выполнился код в конечном условии `else` (все остальное).

[К содержанию](#up)
***
КОНЕЦ ПЕРВОЙ ЛЕКЦИИ

[Вторая лекция](secondlection.md)
